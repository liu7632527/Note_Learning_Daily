# Java基础语法

## 7.进制

- 十进制：Java中，数值默认都是10进制，不需要加任何修饰。
- 二进制：数值前面以0b开头，b大小写都可以。
- 八进制：数值前面以0开头。
- 十六进制：数值前面以0x开头，x大小写都可以。



### 7.1 任意进制到十进制的转换

​	公式: 系数 * 基数的权次幂相加

​	**二进制**

例如:0b100

拆解:Ob为二进制标识

系数:1 1 0

基数:2(因为当前数值是2进制)

权:从右侧开始,以0为编号,逐个加1

(1 * 2 ^ 2) + (1 * 2 ^ 1) + (0 * 2 ^ 0) = 6

​	**十六进制**

0×110

0x为十六进制标识

(1* 16 ^ 2) + (1 * 16 ^1) + (0 * 16 ^ 0) = 272



### 7.2 十进制到任意进制的转换

​	公式：除基取余使用源数据，不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。

​	或者，直接拆分成每一位权值的和拼凑出来。



### 7.3 快速进制转换

#### 7.3.1二进制转十进制

8421码：

8421码又称BCD码，是BCD代码中最常用的一种BCD： (Binary-Coded Decimal ) 二进制码十进制数在这种编码方式中，每一位二进制值的1都是代表一个固定数值，把每一位的1代表的十进制数加起来得到的结果就是它所代表的十进制数。

  2^7   2^6   2^5    2^4  2^3    2^2    2^1    2^0

  128    64     32     16    8      4      2       1

0b11011011



#### 7.3.2 二进制转八进制

每三位二进制数表示一位八进制数，位数不足二进制最左侧添加0凑位数。



#### 7.3.3 二进制转十六进制

每四位二进制数表示一位八进制数，位数不足二进制最左侧添加0凑位数。



### 7.4 原码反码补码

在计算机当中都是使用**补码**  来进行计算和存储的，补码是通过反码和原码推算出来的

**原码**

十进制数据的二进制表现形式就是原码，原码最左边的一个数字就是符号位，0为正，1为负

**反码**

正数的反码是其本身（等于原码），负数的反码是符号位保持不变，其余位取反。

**补码**

正数的补码是其本身，负数的补码等于其反码 +1。



### 7.5位运算

位运算符指的是二进制位的运算，先将数转成**二进制后再进行运算。**



#### 7.5.1 基本位运算符

| 符号               | 作用   |
| ------------------ | ------ |
| &                  | 位与   |
| \|                 | 位或   |
| !       /        ~ | 位非   |
| ^                  | 位异或 |



#### 7.5.2 位移运算符

**带符号位移运算**

| 数                        | 左移 << 1位    | 右移 >> 1 位   |
| ------------------------- | -------------- | -------------- |
| 正数 (35的补码 00100011)  | 01000110 = 70  | 00010001 = 17  |
| 负数 (-35的补码 11011101) | 10111010 = -70 | 11101110 = -18 |
| 正数(99的补码 01100011)   | 11000110 = -58 | 00110001 = 49  |
| 负数(99的补码 10011101)   | 00111010 = 58  | 11001110 = -50 |

左移运算由于符号位参与向左移动，移动后的结果，最左位可能是0或者1，即，正数向左移动的结果可能是正，也可能是负；负数向左移动的结果可能是正，也可能是负。

所有的位移运算相当于要先将位移的数进行取模

i << x  

**运算规律:**

- << 向左移动几位, 就是乘以2的几次幂

- \>> 向右移动几位, 就是除以2的几次幂 

**无符号位移运算**

| 数                        | 右移 >>> 1位   | 向右移 >>> 2位 | 向右移 >>> 3位 |
| ------------------------- | -------------- | -------------- | -------------- |
| 正数 (35的补码 00100011)  | 00010001 = 17  | 00001000 = 8   | 00000100 = 4   |
| 负数 (-35的补码 11011101) | 01101110 = 110 | 00110111 = 55  | 00011011 = 27  |

​	对于3个大于号的>>>无符号向右移动（注意不存在无符号向左移动的运算方式），当向右移动时，正负数高位均补0。

 

## 8.方法

​	方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集

注意：

- 方法必须先创建才可以使用，该过程成为方法定义
- 方法创建后并不是直接可以运行的，需要手动使用后，才执行，该过程成为方法调用
- 我们现在的方法都有static关键词，但这不是必须的！！！
- 按照小驼峰的方式命名，且无先后编写顺序，但最好按照首字母顺序排序！！！！



### 8.1 无参数方法

格式：

```java
public static void 方法名 (   ) {
   // 方法体;
}
```

注意：

-   方法必须先定义，后调用，否则程序将报错
-   每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失。

### 8.2带参数的方法

**格式：**

参数：由数据类型和变量名组成 - 数据类型 变量名

```java
public static void 方法名 (参数1) {
   方法体;
}
 
public static void 方法名 (参数1, 参数2, 参数3...) {
   方法体;
}
```

**注意：**

- 方法定义时，参数中的数据类型与变量名都不能缺少，缺少任意一个程序将报错

- 方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错 

**调用方式：**

```java
方法名(参数)；
```



#### 8.2.1形参和实参

1. 形参：方法定义中的参数

​     等同于变量定义格式，例如：int number

2. 实参：方法调用中的参数

​     等同于使用变量或常量，例如： 10 number



### 8.3 带返回值方法

**格式：**

```java
public static 数据类型 方法名 ( 参数 ) {
    return 数据 ;
}
```

**范例：**

```java
public static int getMax( int a, int b ) {
    return a>b?a:b;
}
```

**注意：**

方法定义时return后面的返回值与方法定义上的数据类型要匹配，否则程序将报错

**调用格式:**

```java
方法名 ( 参数 ) ;数据类型 变量名 = 方法名 ( 参数 ) ;
```

**范例：**

```java
getMax(1,2);
int a = getMax(1,2);
```

**注意：**

方法的返回值通常会使用变量接收，否则该返回值将无意义



### 8.4 注意事项

1.不能嵌套定义

> public static void test1() {
>
> ​    public static void test2() {
>
> ​       // 这里会引发编译错误!!!
>
> ​    }
>
> }

2.void表示无返回值，可以写单独的return。

> public static void test1() {
>
> ​    //return "x"; 编译错误，因为没有具体返回值类型
>
> ​    return;
>
> ​    //System.out.println("x"); return语句后面不能跟数据或代码
>
> }



### 8.5 方法重载

方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载

- 多个方法在同一个类中
- 多个方法具有相同的方法名
- 多个方法的参数不相同， **类型不同或者数量不同**

注意：

- 不能通过返回值来判定两个方法是否相互构成重载

- 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式

```java
public class MethodDemo {

  public static void fn(int a) {

​    //方法体

  }

  public static int fn(double a) {

​    //方法体

  }

}

 

public class MethodDemo {

  public static float fn(int a) {

​    //方法体

  }

  public static int fn(int a , int b) {

​    //方法体

  }

}
```



#### 错误案例

```java
public class MethodDemo {
   public static void fn(int a) {
       //方法体
    }
    public static int fn(int a) {    /*错误原因：重载与返回值无关*/
       //方法体
    }
}

public class MethodDemo01 {
    public static void fn(int a) {
        //方法体
    }
} 
public class MethodDemo02 {
    public static int fn(double a) { /*错误原因：这是两个类的两个fn方法*/
        //方法体
    }
}
```



### 8.6 参数传递

#### 8.6.1 基本类型

​	基本数据类型的参数，形式参数的改变，不影响实际参数。每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失。

```java
public class Test1 {
    /*
         方法参数传递为基本数据类型 :
 
                传入方法中的, 是具体的数值.
     */
    public static void main(String[] args) {
        int number = 100;
        System.out.println("调用change方法前:" + number);
        change(number);
        System.out.println("调用change方法后:" + number);
    }
 
    public static void change(int number) {
        number = 200;
    }
}
```



#### 8.6.2 引用类型

​	引用类型的形式参数的改变，影响实际参数的值，因为引用数据类型的传参，传入的是地址值，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果。

```java
package com.xinqi.param;
 
public class Test2 {
    /*
         方法参数传递为引用数据类型 :
 
                传入方法中的, 是内存地址.
     */
    public static void main(String[] args) {
        int[] arr = {10, 20, 30};
        System.out.println("调用change方法前:" + arr[1]);
        change(arr);
        System.out.println("调用change方法后:" + arr[1]);
    }
 
    public static void change(int[] arr) {
        arr[1] = 200;
    }
}
```



### 8.7 Debug模式

​	是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。



### 8.8 方法调用内存情况

栈内存：

​	所有的代码均在方法区，在内存外。

​	从 `main` 函数作为入口开始，顺序执行所有的语句，作为一个块调入到栈内存当中

​	当遇到第一个调用的函数时，会调用方法的函数块调入栈内存中，若有方法调用则会

​	。。。。。。

​	当`main`执行完之后，调出栈内存。



## 9.面向对象



### 9.1 类和对象

​	面向对象和面向过程的思想对比 :

- 面向过程 ：是一种以过程为中心的编程思想，实现功能的每一步，都是自己实现的
- 面向对象 ：是一种以对象为中心的编程思想，通过**指挥对象实现具体的功能**



### 9.2 类和对象的关系

类的理解

- 类是对现实生活中一类具有共同属性和行为的事物的抽象
- 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合
- 简单理解：类就是对现实事物的一种描述

类的组成

- 属性：指事物的特征，例如：手机事物（品牌，价格，尺寸）
- 行为：指事物能执行的操作，例如：手机事物（打电话，发短信）

类和对象的关系

- 类：类是对现实生活中一类具有共同属性和行为的事物的抽象
- 对象：是一种真实存在，但不一定是实体，如比特币
- 简单理解：类是对事物的一种描述，对象则为具体存在的事物



### 9.3 类的定义

类的组成是由属性和行为两部分组成

- 属性：在类中通过成员变量来体现（类中方法外的变量）
- 行为：在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）

类的定义步骤：

  ① 定义类

  ② 编写类的成员变量

  ③ 编写类的成员方法 

```java
public class Student {
    // 属性 : 姓名, 年龄
    // 成员变量: 跟之前定义变量的格式一样, 只不过位置发生了改变, 类中方法外
    String name;
    int age;

    // 行为 : 学习
    // 成员方法: 跟之前定义方法的格式一样, 只不过去掉了static关键字.
    public void study(){
        System.out.println("学习");
    }
}
```

